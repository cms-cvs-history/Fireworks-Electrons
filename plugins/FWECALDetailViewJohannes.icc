#include "TAxis.h"
#include "TGLViewer.h"
#include "TCanvas.h"
#include "TRootEmbeddedCanvas.h"
#include "TMath.h"
#include "TLatex.h"

#include "TEveViewer.h"
#include "TEveScene.h"
#include "TEveManager.h"
#include "TEveCaloData.h"
#include "TEveCalo.h"
#include "TEveCaloLegoOverlay.h"
#define protected public
#include "TEveLegoEventHandler.h"
#undef protected
#include "TEveStraightLineSet.h"


#include "Fireworks/Core/interface/FWDetailView.h"
#include "Fireworks/Core/interface/FWModelId.h"
#include "Fireworks/Core/interface/FWEventItem.h"
#include "Fireworks/Core/interface/DetIdToMatrix.h"

#include "DataFormats/FWLite/interface/Event.h"
#include "DataFormats/FWLite/interface/Handle.h"
#include "DataFormats/EgammaReco/interface/BasicClusterShapeAssociation.h"
#include "DataFormats/EgammaReco/interface/BasicCluster.h"
#include "DataFormats/EcalDetId/interface/EBDetId.h"
#include "DataFormats/EcalDetId/interface/EEDetId.h"

template <typename T> class FWECALDetailViewJohannes {
public:
   FWECALDetailViewJohannes() {}
   virtual ~FWECALDetailViewJohannes(){}

   virtual void build(const FWModelId &id, const T *, TGCompositeFrame*, TEveScene*, TEveViewer*);

   TEveCaloLego* getLego() { return m_lego;}
   int       getSubdetId() { return m_seedDetIds.size() != 0 ? m_seedDetIds.begin()->first.subdetId() : 0; }
   TCanvas*  getTextCanvas() {return m_textCanvas;}

private:
   FWECALDetailViewJohannes(const FWECALDetailViewJohannes&); // stop default
   const FWECALDetailViewJohannes& operator=(const FWECALDetailViewJohannes&); // stop default

   void fillData (const std::vector< std::pair<DetId, float> > &detids,
                  TEveCaloDataVec *data,
                  double phi_seed);

   void makeBaseLegend(const T *);

   const EcalRecHitCollection *m_barrel_hits;
   const EcalRecHitCollection *m_endcap_hits;
   const EcalRecHitCollection *m_endcap_reduced_hits;
   std::vector< std::pair<DetId, float> > m_seedDetIds;

   Double_t   m_unitCM;
   const FWEventItem* m_item;
   bool  m_coordEtaPhi; // use XY coordinate if EndCap, else EtaPhi
   TCanvas* m_textCanvas;
   TEveCaloLego* m_lego;
};


template <typename T>
void FWECALDetailViewJohannes<T>::build(const FWModelId &id, const T *i, TGCompositeFrame *ediFrame, TEveScene *scene, TEveViewer *viewer)
{
   m_item = id.item();
   const fwlite::Event *ev = m_item->getEvent();
   fwlite::Handle<EcalRecHitCollection> handle_barrel_hits;
   m_barrel_hits = 0;
   try {
      handle_barrel_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEB");
      m_barrel_hits = handle_barrel_hits.ptr();
   }
   catch (...)
   {
      std::cout <<"no barrel ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }

   fwlite::Handle<EcalRecHitCollection> handle_endcap_hits;
   m_endcap_hits = 0;
   try {
      handle_endcap_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEE");
      m_endcap_hits = handle_endcap_hits.ptr();
   }
   catch ( ...)
   {
      std::cout <<"no endcap ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }

   assert(i->superCluster().isNonnull());

   std::vector< std::pair<DetId, float> > detids = i->superCluster()->hitsAndFractions();
   m_seedDetIds = i->superCluster()->seed()-> hitsAndFractions();
   const unsigned int subdetId = m_seedDetIds.size() != 0 ? m_seedDetIds.begin()->first.subdetId() : 0;
   m_coordEtaPhi = (subdetId == EcalEndcap) ? kFALSE: kTRUE;


   // points for centroids
   Double_t x(0), y(0), z(0);
   TEveStraightLineSet *scposition = new TEveStraightLineSet("sc position");
   scposition->SetDepthTest(kFALSE);
   if (subdetId == EcalBarrel) {
      x = i->caloPosition().eta();
      y = i->caloPosition().phi();
   } else if (subdetId == EcalEndcap) {
      x = i->caloPosition().x()*m_unitCM;
      y = i->caloPosition().y()*m_unitCM;
   }
   scposition->AddLine(x, y, z, x, y, z);
   scposition->AddMarker(0, 0.5);
   scposition->SetMarkerSize(2);
   scposition->SetMarkerColor(kBlue);
   scene->AddElement(scposition);

   // points for seed position
   TEveStraightLineSet *seedposition = new TEveStraightLineSet("seed position");
   seedposition->SetDepthTest(kFALSE);
   if (subdetId == EcalBarrel) {
      x  = i->superCluster()->seed()->position().eta();
      y  = i->superCluster()->seed()->position().phi();
   } else if (subdetId == EcalEndcap) {
      x  = i->superCluster()->seed()->position().x()*m_unitCM;
      y  = i->superCluster()->seed()->position().y()*m_unitCM;
   }
   seedposition->AddLine(x, y, z, x, y, z);
   seedposition->AddMarker(0, 0.5);
   seedposition->SetMarkerSize(2);
   seedposition->SetMarkerColor(kRed);
   scene->AddElement(seedposition);

   // data
   //
   TEveCaloDataVec* data = new TEveCaloDataVec(3);
   data->RefSliceInfo(0).Setup("seed cluster", 0.0, kMagenta+2);
   data->RefSliceInfo(1).Setup("other clusters", 0.0, kMagenta-5);
   data->RefSliceInfo(2).Setup("track intersections", 0.0, kWhite);

   // fill
   fillData(detids, data, i->superCluster()->seed()->position().phi());

   // make grid
   Double_t em, eM, pm, pM;
   data->GetEtaLimits(em, eM);
   data->GetPhiLimits(pm, pM);
   data->SetAxisFromBins((eM-em)*0.05, (pM-pm)*0.05); // 5% percision
   if (detids.size() > 0 && detids.begin()->first.subdetId() == EcalEndcap) {
      data->GetEtaBins()->SetTitle("X[m]");
      data->GetPhiBins()->SetTitle("Y[m]");
   } else {
      data->GetEtaBins()->SetTitleFont(122);
      data->GetEtaBins()->SetTitle("h");
      data->GetPhiBins()->SetTitleFont(122);
      data->GetPhiBins()->SetTitle("f");
   }
   // add offset
   if (0)
   {
      Float_t offe = (eM-em)*0.1;
      Float_t offp = (pM-pm)*0.1;
      em -= offe;
      eM += offe;
      pm -= offp;
      pM += offp;
      data->AddTower(em, eM, pm, pM);
      data->FillSlice(2, 0);
   }
   // lego
   m_lego = new TEveCaloLego(data);
   // scale and translate to real world coordinates
   m_lego->SetEta(em, eM);
   m_lego->SetPhiWithRng((pm+pM)*0.5, (pM-pm)*0.5); // phi range = 2* phiOffset
   Double_t legoScale = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
   m_lego->InitMainTrans();
   m_lego->RefMainTrans().SetScale(legoScale, legoScale, legoScale*0.5);
   m_lego->RefMainTrans().SetPos((eM+em)*0.5, (pM+pm)*0.5, 0);

   m_lego->SetAutoRebin(kFALSE);
   m_lego->Set2DMode(TEveCaloLego::kValSize);
   m_lego->SetProjection(TEveCaloLego::kAuto);
   m_lego->SetName("ECALDetail Lego");
   m_lego->SetFontColor(kGray);
   scene->AddElement(m_lego);

   // draw axis at the window corners
   TGLViewer* glv =  viewer->GetGLViewer();
   TEveCaloLegoOverlay* overlay = new TEveCaloLegoOverlay();
   overlay->SetShowPlane(kFALSE);
   overlay->SetShowPerspective(kFALSE);
   overlay->SetCaloLego(m_lego);
   glv->AddOverlayElement(overlay);

   // set event handler and flip camera to top view at beginning
   glv->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
   TEveLegoEventHandler* eh = new TEveLegoEventHandler("Lego",(TGWindow*)glv->GetGLWidget(), (TObject*)glv);
   glv->SetEventHandler(eh);
   eh->Rotate(0, 10000, kFALSE, kFALSE);

   glv->UpdateScene();
   glv->CurrentCamera().Reset();

   // draw legend in latex
   TRootEmbeddedCanvas* ec = new TRootEmbeddedCanvas("Embeddedcanvas", ediFrame, 100, 100, 0);
   ediFrame->AddFrame(ec, new TGLayoutHints(kLHintsExpandX|kLHintsExpandY));
   ediFrame->MapSubwindows();
   ediFrame->Layout();
   m_textCanvas = ec->GetCanvas();
   m_textCanvas->SetBorderMode(0);
   makeBaseLegend(i);
}

template <typename T>
void FWECALDetailViewJohannes<T>::fillData (const std::vector< std::pair<DetId, float> > &detids,
                                    TEveCaloDataVec *data,
                                    double phi_seed)
{
   for (std::vector< std::pair<DetId, float> >::const_iterator k = detids.begin();
        k != detids.end(); ++k) {
      double size = 50; // default size
      if (k->first.subdetId() == EcalBarrel) {
         if (m_barrel_hits != 0) {
            EcalRecHitCollection::const_iterator hit =
               m_barrel_hits->find(k->first);
            if (hit != m_barrel_hits->end()) {
               size = hit->energy();
            }
         }
      } else if (k->first.subdetId() == EcalEndcap) {
         if (m_endcap_hits != 0) {
            EcalRecHitCollection::const_iterator hit =
               m_endcap_hits->find(k->first);
            if (hit != m_endcap_hits->end()) {
               size = hit->energy();
            }
         }
      }
      const TGeoHMatrix *matrix = m_item->getGeom()->getMatrix(k->first.rawId());
      if ( matrix == 0 ) {
         printf("Warning: cannot get geometry for DetId: %d. Ignored.\n",k->first.rawId());
         continue;
      }
      TVector3 v(matrix->GetTranslation()[0],
                 matrix->GetTranslation()[1],
                 matrix->GetTranslation()[2]);
      int slice = 1;
      for (std::vector< std::pair<DetId, float> >::const_iterator i = m_seedDetIds.begin();
           i != m_seedDetIds.end(); ++i){
         if ( i->first == k->first) {
            slice = 0;
            break;
         }
      }


      if (m_coordEtaPhi) {
         double phi = v.Phi();
         if (v.Phi() > phi_seed + M_PI)
            phi -= 2 * M_PI;
         if (v.Phi() < phi_seed - M_PI)
            phi += 2 * M_PI;
         data->AddTower(v.Eta() - 0.0172 / 2, v.Eta() + 0.0172 / 2,
                        phi - 0.0172 / 2, phi + 0.0172 / 2);
         data->FillSlice(slice, size);
      } else if (k->first.subdetId() == EcalEndcap) {
         // switch from cm to m
         data->AddTower((v.X() - 2.9 / 2)*m_unitCM, (v.X() + 2.9 / 2)*m_unitCM,
                        (v.Y() - 2.9 / 2)*m_unitCM, (v.Y() + 2.9 / 2)*m_unitCM);
         data->FillSlice(slice, size);
      }
   }
   data->DataChanged();
}

template <typename T>
void FWECALDetailViewJohannes<T>::makeBaseLegend (const T *item)
{
   TLatex* latex = new TLatex(0.02, 0.970, "");
   latex->SetTextSize(0.06);

   float_t x = 0.02;
   float_t x2 = 0.52;
   float   y = 0.95;
   float fontsize = latex->GetTextSize()*0.6;

   // legend
   latex->DrawLatex(x, y, "#color[2]{#bullet} seed cluster centroid");
   y -= fontsize;
   latex->DrawLatex(x, y, "#color[4]{#bullet} supercluster centroid");
   y -= fontsize;
   latex->DrawLatex(x, y, "#color[618]{#Box} seed cluster");
   y -= fontsize;
   latex->DrawLatex(x, y, "#color[608]{#Box} other clusters"); // kCyan+1
   // eta, phi axis or x, y axis?
   assert(item->superCluster().isNonnull());
   y -= fontsize;
   // summary
   char summary[128];
   sprintf(summary, "%s = %.1f GeV",
           "E_{T}", item->et());
   latex->DrawLatex(x, y, summary);
   y -= fontsize;

   // E/p, H/E
   char hoe[128];
   sprintf(hoe, "H/E = %.3f", item->hadronicOverEm());
   latex->DrawLatex(x, y, hoe);
   y -= fontsize;

   // phi eta
   char ephi[30];
   sprintf(ephi, " #eta = %.2f", item->eta());
   latex->DrawLatex(x, y, ephi);
   sprintf(ephi, " #varphi = %.2f", item->phi());
   latex->DrawLatex(x2, y, ephi);
   y -= 2*fontsize;
}
