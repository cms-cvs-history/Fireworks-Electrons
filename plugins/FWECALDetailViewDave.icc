
#include "TEveViewer.h"
#include "TEveScene.h"
#include "TEveManager.h"
#include "Fireworks/Core/interface/FWModelId.h"
#include "Fireworks/Core/interface/FWEventItem.h"

template <typename T> class FWECALDetailViewDave {
public:
   FWECALDetailViewDave() { }
   virtual ~FWECALDetailViewDave(){}

   virtual void build(const FWModelId &id, const T *, TGCompositeFrame*, TEveScene*, TEveViewer*);


private:
   FWECALDetailViewDave(const FWECALDetailViewDave&); // stop default
   const FWECALDetailViewDave& operator=(const FWECALDetailViewDave&); // stop default
  
   void fillData (const std::vector<DetId> &detids, const std::vector<std::pair<DetId, int> > &scdetids,
                  TEveCaloDataVec *data,
                  double phi_seed);    
   
   const EcalRecHitCollection *m_barrel_hits;
   const EcalRecHitCollection *m_endcap_hits;   
	const reco::SuperClusterCollection *m_barrel_superclusters;
	
   const FWEventItem* m_item;
   bool  m_coordEtaPhi; // use XY coordinate if EndCap, else EtaPhi
   TCanvas* m_textCanvas;

   Double_t   m_unitCM;
   TEveCaloLego* m_lego;

};


template <typename T>
void FWECALDetailViewDave<T>::build(const FWModelId &id, const T *i, TGCompositeFrame*ediFrame, TEveScene* scene, TEveViewer*viewer)
{
   m_item = id.item();
   const fwlite::Event *ev = m_item->getEvent();
   fwlite::Handle<EcalRecHitCollection> handle_barrel_hits;
   m_barrel_hits = 0;
   try {
      handle_barrel_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEB");
      m_barrel_hits = handle_barrel_hits.ptr();
   }
   catch (...)
   {
      std::cout <<"no barrel ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }

   fwlite::Handle<EcalRecHitCollection> handle_endcap_hits;
   m_endcap_hits = 0;
   try {
      handle_endcap_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEE");
      m_endcap_hits = handle_endcap_hits.ptr();
   }
   catch ( ...)
   {
      std::cout <<"no endcap ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }
   
   fwlite::Handle<reco::SuperClusterCollection> handle_barrel_superclusters;
   m_barrel_superclusters = 0;
   try {
      handle_barrel_superclusters.getByLabel(*ev, "correctedHybridSuperClusters");
      m_barrel_superclusters = handle_barrel_superclusters.ptr();
   }
   catch ( ...)
   {
      std::cout <<"no barrel superclusters are available" << std::endl;
   }

	// what does this do?  In JM code it looked like it was uninitialised.
	m_unitCM = 0;

	// get all the detids
   std::vector<DetId> detids;
   for (size_t i = 0; i < m_barrel_hits->size(); ++i)
   {
		detids.push_back((*m_barrel_hits)[i].id());
   }
   
   
   
   // data
   //
   TEveCaloDataVec* data = new TEveCaloDataVec(1 + m_barrel_superclusters->size());
   data->RefSliceInfo(0).Setup("hits (not clustered)", 0.0, kMagenta+2);   
   
   // get the detids that are in superclusters
   // and add a coloured slice for each supercluster
   std::vector<std::pair<DetId, int> > scdetids;
   for (size_t i = 0; i < m_barrel_superclusters->size(); ++i)
   {
   
		data->RefSliceInfo(1 + i).Setup("hits in SC", 0.0, kGreen + i + 2);
		
		std::vector< std::pair<DetId, float> > these_ids;
		these_ids = (*m_barrel_superclusters)[i].hitsAndFractions();
		for (size_t j = 0; j < these_ids.size(); ++j)
		{
			scdetids.push_back(std::make_pair(these_ids[j].first, i));
		}
	}   
   
	// for now just testing in the barrel
	m_coordEtaPhi = kTRUE;
	




   // fill
	// note - phi seed not doing anything right now
   fillData(detids, scdetids, data, 3.14159);
   
   //
   // bits I do not need to change
   //
   
   
   
   
   
   // make grid
   Double_t em, eM, pm, pM;
   data->GetEtaLimits(em, eM);
   data->GetPhiLimits(pm, pM);
   data->SetAxisFromBins((eM-em)*0.05, (pM-pm)*0.05); // 5% percision
   if (detids.size() > 0 && detids.begin()->subdetId() == EcalEndcap) {
      data->GetEtaBins()->SetTitle("X[m]");
      data->GetPhiBins()->SetTitle("Y[m]");
   } else {
      data->GetEtaBins()->SetTitleFont(122);
      data->GetEtaBins()->SetTitle("h");
      data->GetPhiBins()->SetTitleFont(122);
      data->GetPhiBins()->SetTitle("f");
   }
   // add offset
   if (0)
   {
      Float_t offe = (eM-em)*0.1;
      Float_t offp = (pM-pm)*0.1;
      em -= offe;
      eM += offe;
      pm -= offp;
      pM += offp;
      data->AddTower(em, eM, pm, pM);
      data->FillSlice(2, 0);
   }
   // lego
   m_lego = new TEveCaloLego(data);
   // scale and translate to real world coordinates
   m_lego->SetEta(em, eM);
   m_lego->SetPhiWithRng((pm+pM)*0.5, (pM-pm)*0.5); // phi range = 2* phiOffset
   Double_t legoScale = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
   m_lego->InitMainTrans();
   m_lego->RefMainTrans().SetScale(legoScale, legoScale, legoScale*0.5);
   m_lego->RefMainTrans().SetPos((eM+em)*0.5, (pM+pm)*0.5, 0);

   m_lego->SetAutoRebin(kFALSE);
   m_lego->Set2DMode(TEveCaloLego::kValSize);
   m_lego->SetProjection(TEveCaloLego::kAuto);
   m_lego->SetName("ECALDetail Lego");
   m_lego->SetFontColor(kGray);
   scene->AddElement(m_lego);

   // draw axis at the window corners
   TGLViewer* glv =  viewer->GetGLViewer();
   TEveCaloLegoOverlay* overlay = new TEveCaloLegoOverlay();
   overlay->SetShowPlane(kFALSE);
   overlay->SetShowPerspective(kFALSE);
   overlay->SetCaloLego(m_lego);
   glv->AddOverlayElement(overlay);

   // set event handler and flip camera to top view at beginning
   glv->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
   TEveLegoEventHandler* eh = new TEveLegoEventHandler("Lego",(TGWindow*)glv->GetGLWidget(), (TObject*)glv);
   glv->SetEventHandler(eh);

   glv->UpdateScene();
   glv->CurrentCamera().Reset();

   
}

template <typename T>
void FWECALDetailViewDave<T>::fillData (const std::vector<DetId> &detids, 
									const std::vector<std::pair<DetId, int> > &scdetids,
                                    TEveCaloDataVec *data,
                                    double phi_seed)
{

	// loop on all the detids
   for (std::vector<DetId>::const_iterator k = detids.begin();
        k != detids.end(); ++k) {
		
      double size = 50; // default size
      if (k->subdetId() == EcalBarrel) {
         if (m_barrel_hits != 0) {
            EcalRecHitCollection::const_iterator hit = m_barrel_hits->find(*k);
            if (hit != m_barrel_hits->end()) {
               size = hit->energy();
            }
         }
      } else if (k->subdetId() == EcalEndcap) {
         if (m_endcap_hits != 0) {
            EcalRecHitCollection::const_iterator hit =
               m_endcap_hits->find(*k);
            if (hit != m_endcap_hits->end()) {
               size = hit->energy();
            }
         }
      }
      const TGeoHMatrix *matrix = m_item->getGeom()->getMatrix(k->rawId());
      if ( matrix == 0 ) {
         printf("Warning: cannot get geometry for DetId: %d. Ignored.\n",k->rawId());
         continue;
      }
	  
      TVector3 v(matrix->GetTranslation()[0],
                 matrix->GetTranslation()[1],
                 matrix->GetTranslation()[2]);
				 
				 
				 
		// is the det id in a supercluster or not?
		// if so, set the hit to go in the correct slice for that sc
		int slice = 0;
		for (size_t i = 0; i < scdetids.size(); ++i)
		{
			if (scdetids[i].first == *k) {
				slice = 1 + scdetids[i].second;
				break;
			}
		}
	
      if (m_coordEtaPhi) {
         double phi = v.Phi();
         //if (v.Phi() > phi_seed + M_PI)
         //   phi -= 2 * M_PI;
         //if (v.Phi() < phi_seed - M_PI)
         //   phi += 2 * M_PI;
         data->AddTower(v.Eta() - 0.0172 / 2, v.Eta() + 0.0172 / 2,
                        phi - 0.0172 / 2, phi + 0.0172 / 2);
         data->FillSlice(slice, size);
      } else if (k->subdetId() == EcalEndcap) {
         // switch from cm to m
         data->AddTower((v.X() - 2.9 / 2)*m_unitCM, (v.X() + 2.9 / 2)*m_unitCM,
                        (v.Y() - 2.9 / 2)*m_unitCM, (v.Y() + 2.9 / 2)*m_unitCM);
         data->FillSlice(slice, size);
      }
	  
   } // end loop on hits
   
   data->DataChanged();

}
