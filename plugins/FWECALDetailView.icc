// $Id: FWECALDetailView.icc,v 1.14 2009/07/15 18:58:31 amraktad Exp $

// system include files
#include "TLatex.h"
#include "TAxis.h"
#include "TGeoBBox.h"

#include "TGLViewer.h"
#include "TGLOverlayButton.h"

#include "TEveManager.h"
#include "TEveCalo.h"
#include "TEveCaloData.h"
#define protected public
#include "TEveLegoEventHandler.h"
#undef protected
#include "TEveCaloLegoOverlay.h"
#include "TEveText.h"
#include "TEveGeoNode.h"
#include "TEveStraightLineSet.h"
#include "TEveTrack.h"
#include "TEveTrackPropagator.h"

// user include files
#include "Fireworks/Electrons/plugins/FWECALDetailView.h"
#include "Fireworks/Core/interface/FWDetailView.h"

#include "DataFormats/FWLite/interface/Event.h"
#include "DataFormats/FWLite/interface/Handle.h"
#include "Fireworks/Core/interface/FWModelId.h"
#include "Fireworks/Core/interface/FWEventItem.h"
#include "Fireworks/Core/interface/DetIdToMatrix.h"
#include "Fireworks/Core/interface/TEveElementIter.h"
#include "DataFormats/EgammaReco/interface/BasicClusterShapeAssociation.h"
#include "DataFormats/EgammaReco/interface/BasicCluster.h"
#include "DataFormats/EcalDetId/interface/EBDetId.h"
#include "DataFormats/EcalDetId/interface/EEDetId.h"
#include "DataFormats/EcalDetId/interface/EcalSubdetector.h"

template <typename T>
FWECALDetailView<T>::FWECALDetailView () :
   m_item(0),
   m_coordEtaPhi(true),
   m_barrel_hits(0),
   m_endcap_hits(0),
   m_endcap_reduced_hits(0)
{
}

template <typename T>
FWECALDetailView<T>::~FWECALDetailView ()
{

}

template <typename T>
void  FWECALDetailView<T>::clearOverlayElements()
{
   TGLViewer* v =  FWDetailViewBase::viewer();
   for(std::vector<TGLOverlayElement* >::iterator it = m_overlays.begin();  it != m_overlays.end(); it++)
   {
      v->RemoveOverlayElement(*it);
   }
   m_overlays.clear();
}


template <typename T>
math::XYZPoint FWECALDetailView<T>::trackPositionAtCalo (const T &)
{
   return math::XYZPoint();
}

template <typename T>
double FWECALDetailView<T>::deltaEtaSuperClusterTrackAtVtx (const T &)
{
   return 0;
}

template <typename T>
double FWECALDetailView<T>::deltaPhiSuperClusterTrackAtVtx (const T &)
{
   return 0;
}

template <typename T>
void FWECALDetailView<T>::build_projected (const FWModelId &id, const T *i,
					   class TEveElementList *tList)
{
   // get rechits
   const fwlite::Event *ev = m_item->getEvent();
   fwlite::Handle<EcalRecHitCollection> handle_barrel_hits;
   m_barrel_hits = 0;
   try {
      handle_barrel_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEB");
      m_barrel_hits = handle_barrel_hits.ptr();
   }
   catch (...)
   {
      std::cout <<"no barrel ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }
   fwlite::Handle<EcalRecHitCollection> handle_endcap_hits;
   m_endcap_hits = 0;
   try {
      handle_endcap_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEE");
      m_endcap_hits = handle_endcap_hits.ptr();
   }
   catch ( ...)
   {
      std::cout <<"no endcap ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }

   assert(i->superCluster().isNonnull());


   tList->AddElement(makeLabels(*i));
   std::vector< std::pair<DetId, float> > detids = i->superCluster()->hitsAndFractions();
   seed_detids = i->superCluster()->seed()-> hitsAndFractions();
   const unsigned int subdetId = seed_detids.size() != 0 ? seed_detids.begin()->first.subdetId() : 0;
   m_coordEtaPhi = (subdetId == EcalEndcap) ? kFALSE: kTRUE;

   // data
   //
   TEveCaloDataVec* data = new TEveCaloDataVec(3);
   data->SetWrapTwoPi(kFALSE);
   data->RefSliceInfo(0).Setup("seed cluster", 0.0, kMagenta+2);
   data->RefSliceInfo(1).Setup("other clusters", 0.0, kMagenta-5);
   data->RefSliceInfo(2).Setup("track intersections", 0.0, kWhite);
   // fill
   fillData(detids, data, i->superCluster()->seed()->position().phi());
   if (drawTrack()) addTrackPointsInCaloData(i, subdetId, data);
   // add grid offset
   Double_t etaMin, etaMax;
   Double_t phiMin, phiMax;
   data->GetEtaLimits(etaMin, etaMax);
   data->GetPhiLimits(phiMin, phiMax);
   Float_t offe = 0.1*(etaMax -etaMin);
   Float_t offp = 0.1*(etaMax -etaMin);
   data->AddTower(etaMin -offe, etaMax +offe, phiMin -offp , phiMax +offp);
   data->FillSlice(2, 0);
   // set grid resolution
   data->SetAxisFromBins(1e-2, 1e-2);
   // set eta, phi axis title with symbol.ttf font
   if (detids.size() > 0 && detids.begin()->first.subdetId() == EcalEndcap) {
      data->GetEtaBins()->SetTitle("X[cm]");
      data->GetPhiBins()->SetTitle("Y[cm]");
   } else {
      data->GetEtaBins()->SetTitleFont(122);
      data->GetEtaBins()->SetTitle("h");
      data->GetPhiBins()->SetTitleFont(122);
      data->GetPhiBins()->SetTitle("f");
   }
   data->DataChanged();

   // lego
   //
   TEveCaloLego* lego = new TEveCaloLego(data);
   Double_t em, eM, pm, pM;
   data->GetEtaLimits(em, eM);
   data->GetPhiLimits(pm, pM);
   lego->SetEta(em, eM);
   lego->SetPhiWithRng((pm+pM)*0.5, (pM-pm)*0.5); // phi range = 2* phiOffset
   // scale and translate to real world coordinates
   Double_t legoScale = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
   lego->InitMainTrans();
   lego->RefMainTrans().SetScale(legoScale, legoScale, legoScale);
   lego->RefMainTrans().SetPos((eM+em)*0.5, (pM+pm)*0.5, 0);
   lego->SetAutoRebin(kFALSE);
   lego->Set2DMode(TEveCaloLego::kValSize);
   lego->SetProjection(TEveCaloLego::kAuto);
   lego->SetName("ElectronDetail Lego");
   lego->SetFontColor(kGray);
   gEve->AddElement(lego, tList);

   // draw axis at the window corners
   TEveCaloLegoOverlay* overlay = new TEveCaloLegoOverlay();
   overlay->SetShowPlane(kFALSE);
   overlay->SetShowPerspective(kFALSE);
   overlay->SetCaloLego(lego);
   FWDetailViewBase::viewer()->AddOverlayElement(overlay);
   m_overlays.push_back(overlay);

   // set event handler and flip camera to top view at beginning
   FWDetailViewBase::viewer()->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
   TGLViewer* fwdv =  FWDetailViewBase::viewer();
   TEveLegoEventHandler* eh = new TEveLegoEventHandler("Lego",(TGWindow*)fwdv->GetGLWidget(), (TObject*)fwdv);
   fwdv->SetEventHandler(eh);
   eh->Rotate(0, 10000, kFALSE, kFALSE);

   // points for centroids
   TEveStraightLineSet *scposition = new TEveStraightLineSet("sc position");
   scposition->SetDepthTest(kFALSE);
   scposition->AddLine(i->caloPosition().eta(),
                       i->caloPosition().phi(),
                       0,
                       i->caloPosition().eta(),
                       i->caloPosition().phi(),
                       0);
   scposition->AddMarker(0, 0.5);
   scposition->SetMarkerSize(2);
   scposition->SetMarkerColor(kBlue);
   tList->AddElement(scposition);

   // points for seed position
   TEveStraightLineSet *seedposition = new TEveStraightLineSet("seed position");
   seedposition->SetDepthTest(kFALSE);
   if (subdetId == EcalBarrel) {
      seedposition->AddLine(i->superCluster()->seed()->position().eta(),
                            i->superCluster()->seed()->position().phi(),
                            0,
                            i->superCluster()->seed()->position().eta(),
                            i->superCluster()->seed()->position().phi(),
                            0);
   } else if (subdetId == EcalEndcap) {
      seedposition->AddLine(i->superCluster()->seed()->position().x(),
                            i->superCluster()->seed()->position().y(),
                            0,
                            i->superCluster()->seed()->position().x(),
                            i->superCluster()->seed()->position().y(),
                            0);
   }
   seedposition->AddMarker(0, 0.5);
   seedposition->SetMarkerSize(2);
   seedposition->SetMarkerColor(kRed);
   tList->AddElement(seedposition);

   if (drawTrack())  drawCrossHair(i, subdetId, lego, tList);
}

//______________________________________________________________________________
template <typename T>
void FWECALDetailView<T>::getEcalCrystalsBarrel (std::vector<DetId> *vv,
						 int ieta, int iphi)
{
   std::vector<DetId> &v = *vv;
   const int n_eta = 10;
   const int n_phi = 20;
   v.reserve((2 * n_eta + 1) * (2 * n_phi + 1));
   for (int i = ieta - n_eta; i < ieta + n_eta; ++i) {
      for (int j = iphi - n_phi; j < iphi + n_phi; ++j) {
         // printf("pushing back (%d, %d)\n", i, j % 360);
         if (EBDetId::validDetId(i, j % 360)) {
            v.push_back(EBDetId(i, j % 360));
            // printf("pushing back (%d, %d)\n", i, j % 360);
         }
      }
   }
}

//______________________________________________________________________________
template <typename T>
void FWECALDetailView<T>::getEcalCrystalsEndcap (std::vector<DetId> *vv,
                                                 int ix, int iy, int iz)
{
   std::vector<DetId> &v = *vv;
   const int n_x = 10;
   const int n_y = 10;
   v.reserve((2 * n_x + 1) * (2 * n_y + 1));
   for (int i = ix - n_x; i < ix + n_x; ++i) {
      for (int j = iy - n_y; j < iy + n_y; ++j) {
         if (EEDetId::validDetId(i, j, iz)) {
            v.push_back(EEDetId(i, j, iz));
         }
      }
   }
}

//______________________________________________________________________________
template <typename T>
void FWECALDetailView<T>::fillData (const std::vector< std::pair<DetId, float> > &detids,
				    TEveCaloDataVec *data,
				    double phi_seed)
{
   for (std::vector< std::pair<DetId, float> >::const_iterator k = detids.begin();
        k != detids.end(); ++k) {
      double size = 50; // default size
      if (k->first.subdetId() == EcalBarrel) {
         if (m_barrel_hits != 0) {
            EcalRecHitCollection::const_iterator hit =
               m_barrel_hits->find(k->first);
            if (hit != m_barrel_hits->end()) {
               size = hit->energy();
            }
         }
      } else if (k->first.subdetId() == EcalEndcap) {
         if (m_endcap_hits != 0) {
            EcalRecHitCollection::const_iterator hit =
               m_endcap_hits->find(k->first);
            if (hit != m_endcap_hits->end()) {
               size = hit->energy();
            }
         }
      }
      const TGeoHMatrix *matrix = m_item->getGeom()->getMatrix(k->first.rawId());
      if ( matrix == 0 ) {
         printf("Warning: cannot get geometry for DetId: %d. Ignored.\n",k->first.rawId());
         continue;
      }
      const TVector3 v(matrix->GetTranslation()[0],
                       matrix->GetTranslation()[1],
                       matrix->GetTranslation()[2]);
      int slice = 1;
      for (std::vector< std::pair<DetId, float> >::const_iterator i = seed_detids.begin();
	   i != seed_detids.end(); ++i){
	 if ( i->first == k->first) {
	    slice = 0;
	    break;
	 }
      }
      if (m_coordEtaPhi) {
         double phi = v.Phi();
         if (v.Phi() > phi_seed + M_PI)
            phi -= 2 * M_PI;
         if (v.Phi() < phi_seed - M_PI)
            phi += 2 * M_PI;
         data->AddTower(v.Eta() - 0.0172 / 2, v.Eta() + 0.0172 / 2,
                        phi - 0.0172 / 2, phi + 0.0172 / 2);
         data->FillSlice(slice, size);
      } else if (k->first.subdetId() == EcalEndcap) {
         data->AddTower((v.X() - 2.9 / 2), (v.X() + 2.9 / 2),
                        (v.Y() - 2.9 / 2), (v.Y() + 2.9 / 2));
         data->FillSlice(slice, size);
      }
   }

}

//______________________________________________________________________________
template <typename T>
void  FWECALDetailView<T>::addTrackPointsInCaloData (const T *i, int subdetId, TEveCaloDataVec *data)
{
#ifdef Fireworks_Electrons_FWElectronDetailView_h
   // add points in third layer
   Float_t eps = 1e-3;
   //   trackpositionAtCalo
   if (subdetId == EcalBarrel) {
      const double eta = i->superCluster()->seed()->position().eta() -
         i->deltaEtaSeedClusterTrackAtCalo();
      const double phi = i->superCluster()->seed()->position().phi() -
         i->deltaPhiSeedClusterTrackAtCalo();
      data->AddTower(eta -eps, eta +eps, phi -eps, phi +eps);
      data->FillSlice(2, 0);
   } else if (subdetId == EcalEndcap) {
      const double eta = i->superCluster()->seed()->position().eta() -
         i->deltaEtaSeedClusterTrackAtCalo();
      const double phi = i->superCluster()->seed()->position().phi() -
         i->deltaPhiSeedClusterTrackAtCalo();
      TVector3 pos;
      pos.SetPtEtaPhi(i->superCluster()->seed()->position().rho(),
                      eta,
                      phi);
      const double x = pos.X();
      const double y = pos.Y();
      data->AddTower(x -eps, x +eps, y -eps, y +eps);
      data->FillSlice(2, 0);
   }

   // pinposition
   if (subdetId == EcalBarrel) {
      const double eta = i->caloPosition().eta() - deltaEtaSuperClusterTrackAtVtx(*i);
      const double phi = i->caloPosition().phi() - deltaPhiSuperClusterTrackAtVtx(*i);
      data->AddTower(eta -eps, eta +eps, phi -eps, phi +eps);
      data->FillSlice(2, 0);
   } else if (subdetId == EcalEndcap) {
      TVector3 pos;
      pos.SetPtEtaPhi(i->caloPosition().rho(),
                      i->caloPosition().eta() - deltaEtaSuperClusterTrackAtVtx(*i),
                      i->caloPosition().phi() - deltaPhiSuperClusterTrackAtVtx(*i));
      const double x = pos.X();
      const double y = pos.Y();
      data->AddTower(x -eps, x +eps, y -eps, y +eps);
      data->FillSlice(2, 0);
   }
#endif
}

//______________________________________________________________________________
template <typename T>
void  FWECALDetailView<T>::drawCrossHair (const T *i, int subdetId, TEveCaloLego *lego, TEveElementList* tList)
{
#ifdef Fireworks_Electrons_FWElectronDetailView_h

   double ymax = lego->GetPhiMax();
   double ymin = lego->GetPhiMin();
   double xmax = lego->GetEtaMax();
   double xmin = lego->GetEtaMin();
   //   printf("lego range: xmin = %f xmax = %f, ymin = %f ymax = %f\n"
   //       , xmin, xmax, ymin, ymax);

   // draw crosshairs for track intersections
   TEveStraightLineSet *trackpositionAtCalo =
      new TEveStraightLineSet("sc trackpositionAtCalo");
   trackpositionAtCalo->SetDepthTest(kFALSE);
   if (subdetId == EcalBarrel) {
      const double eta = i->superCluster()->seed()->position().eta() -
         i->deltaEtaSeedClusterTrackAtCalo();
      const double phi = i->superCluster()->seed()->position().phi() -
         i->deltaPhiSeedClusterTrackAtCalo();
      trackpositionAtCalo->AddLine(eta, ymin, 0,
                                   eta, ymax, 0);
      trackpositionAtCalo->AddLine(xmin, phi, 0,
                                   xmax, phi, 0);
   } else if (subdetId == EcalEndcap) {
      const double eta = i->superCluster()->seed()->position().eta() -
         i->deltaEtaSeedClusterTrackAtCalo();
      const double phi = i->superCluster()->seed()->position().phi() -
         i->deltaPhiSeedClusterTrackAtCalo();
      TVector3 pos;
      pos.SetPtEtaPhi(i->superCluster()->seed()->position().rho(),
                      eta,
                      phi);
      trackpositionAtCalo->AddLine(pos.X(),
                                   ymin,
                                   0,
                                   pos.X(),
                                   ymax,
                                   0);
      trackpositionAtCalo->AddLine(xmin,
                                   pos.Y(),
                                   0,
                                   xmax,
                                   pos.Y(),
                                   0);
   }
   trackpositionAtCalo->SetLineColor(kBlue);
   trackpositionAtCalo->SetPickable(kFALSE);
   tList->AddElement(trackpositionAtCalo);


   TEveStraightLineSet *pinposition = new TEveStraightLineSet("pin position");
   pinposition->SetDepthTest(kFALSE);
   if (subdetId == EcalBarrel) {
      pinposition->AddLine((i->caloPosition().eta() - deltaEtaSuperClusterTrackAtVtx(*i)),
                           ymin,
                           0,
                           (i->caloPosition().eta() - deltaEtaSuperClusterTrackAtVtx(*i)),
                           ymax,
                           0);
      pinposition->AddLine(xmin,
                           (i->caloPosition().phi() - deltaPhiSuperClusterTrackAtVtx(*i)),
                           0,
                           xmax,
                           (i->caloPosition().phi() - deltaPhiSuperClusterTrackAtVtx(*i)),
                           0);
   } else if (subdetId == EcalEndcap) {
      TVector3 pos;
      pos.SetPtEtaPhi(i->caloPosition().rho(),
                      i->caloPosition().eta() - deltaEtaSuperClusterTrackAtVtx(*i),
                      i->caloPosition().phi() - deltaPhiSuperClusterTrackAtVtx(*i));
      pinposition->AddLine(pos.X(),
                           ymin,
                           0,
                           pos.X(),
                           ymax,
                           0);
      pinposition->AddLine(xmin,
                           pos.Y(),
                           0,
                           xmax,
                           pos.Y(),
                           0);
   }
   pinposition->SetLineColor(kRed);
   pinposition->SetPickable(kFALSE);
   tList->AddElement(pinposition);


   printf("TrackPositionAtCalo: %f %f\n",
          trackPositionAtCalo(*i).eta(), trackPositionAtCalo(*i).phi());
   printf("TrackPositionAtCalo: %f %f\n",
          i->superCluster()->seed()->position().eta() -
          i->deltaEtaSeedClusterTrackAtCalo(),
          i->superCluster()->seed()->position().phi() -
          i->deltaPhiSeedClusterTrackAtCalo());
   printf("TrackPositionInner: %f %f\n",
          i->caloPosition().eta() - deltaEtaSuperClusterTrackAtVtx(*i),
          i->caloPosition().phi() - deltaPhiSuperClusterTrackAtVtx(*i));
   printf("calo position %f, deltaEta %f, track position %f\n",
          i->caloPosition().eta(),
          deltaEtaSuperClusterTrackAtVtx(*i),
          trackPositionAtCalo(*i).eta());
#endif
}
