// $Id: FWECALDetailView.icc,v 1.22 2009/08/24 16:22:35 amraktad Exp $

#include "TAxis.h"
#include "TGLViewer.h"
#include "TCanvas.h"
#include "TRootEmbeddedCanvas.h"
#include "TGLabel.h"
#include "TGSlider.h"
#include "TGLFontManager.h"
#include "TGTab.h"
#include "TMath.h"

#include "TEveViewer.h"
#include "TEveScene.h"
#include "TEveManager.h"
#include "TEveWindow.h"
#include "TEveCalo.h"
#include "TEveCaloData.h"
#define protected public
#include "TEveLegoEventHandler.h"
#undef protected
#include "TEveCaloLegoOverlay.h"
#include "TEveText.h"
#include "TEveStraightLineSet.h"
#include "TEveChunkManager.h"


#include "Fireworks/Electrons/plugins/FWECALDetailView.h"
#include "Fireworks/Core/interface/FWDetailView.h"
#include "Fireworks/Core/interface/FWModelId.h"
#include "Fireworks/Core/interface/FWEventItem.h"
#include "Fireworks/Core/interface/DetIdToMatrix.h"
#include "Fireworks/Core/interface/CSGAction.h"

#include "DataFormats/FWLite/interface/Event.h"
#include "DataFormats/FWLite/interface/Handle.h"
#include "DataFormats/EgammaReco/interface/BasicClusterShapeAssociation.h"
#include "DataFormats/EgammaReco/interface/BasicCluster.h"
#include "DataFormats/EcalDetId/interface/EBDetId.h"
#include "DataFormats/EcalDetId/interface/EEDetId.h"
#include "DataFormats/EcalDetId/interface/EcalSubdetector.h"

template <typename T>
FWECALDetailView<T>::FWECALDetailView () :
   m_unitCM(0.01),
   m_item(0),
   m_coordEtaPhi(true),
   m_barrel_hits(0),
   m_endcap_hits(0),
   m_endcap_reduced_hits(0)
{
}

template <typename T>
FWECALDetailView<T>::~FWECALDetailView ()
{

}

template <typename T>
math::XYZPoint FWECALDetailView<T>::trackPositionAtCalo (const T &)
{
   return math::XYZPoint();
}

template <typename T>
double FWECALDetailView<T>::deltaEtaSuperClusterTrackAtVtx (const T &)
{
   return 0;
}

template <typename T>
double FWECALDetailView<T>::deltaPhiSuperClusterTrackAtVtx (const T &)
{
   return 0;
}


template <typename T>
void FWECALDetailView<T>::build_projected(const FWModelId &id, const T *i, TEveWindowSlot* base)
{
   TEveWindowTab* eveWindow = base->MakeTab();
   eveWindow->SetShowTitleBar(kFALSE);
   TEveWindowSlot* slot;

   slot = eveWindow->NewSlot();
   build_projectedJohannes(id, i, slot);

   slot = eveWindow->NewSlot();
   build_projectedLothar(id, i, slot);

   slot = eveWindow->NewSlot();
   build_projectedDave(id, i, slot);

   eveWindow->GetTab()->SetTab(1);
}

//--------------------------------------------------------------------------------
//
//  DetailViewB
//

template <typename T>
void FWECALDetailView<T>::build_projectedLothar(const FWModelId &id, const T *i, TEveWindowSlot* slot)
{
   TGVerticalFrame* ediFrame;
   TEveWindow* ew = FWDetailViewBase::makePackViewer(slot, ediFrame, m_bViewer, m_bScene);
   ew->SetElementName("View B");

   m_bLines = new TEveStraightLineSet();
   m_bLines->SetMarkerColor(6);
   m_bLines->SetMarkerStyle(kGreen);
   m_bScene->AddElement(m_bLines);

   TEveStraightLineSet* a1 = new TEveStraightLineSet();
   a1->AddLine(3, 3, 3, -3, -3, -3);
   a1->SetMainColor(kWhite);
   a1->SetLineStyle(2);
   m_bScene->AddElement(a1);

   setEtaPhiRange(0); // scale 1 = exp 0

   TGLViewer* viewer = m_bViewer->GetGLViewer();
   viewer->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
   TEveLegoEventHandler* eh = new TEveLegoEventHandler("Lego",(TGWindow*)viewer->GetGLWidget(), (TObject*)viewer);
   viewer->SetEventHandler(eh);
   eh->Rotate(0, 10000, kFALSE, kFALSE);
   makeGUIForDetailViewB(ediFrame);
}

template <typename T>
void FWECALDetailView<T>::makeGUIForDetailViewB(TGCompositeFrame* ediFrame)
{
   TGVerticalFrame* guiFrame = new TGVerticalFrame(ediFrame);
   ediFrame->AddFrame(guiFrame, new TGLayoutHints(kLHintsExpandX|kLHintsExpandY));
   guiFrame->SetCleanup(kDeepCleanup);

   TGHorizontalFrame* sliderFrame = new TGHorizontalFrame(guiFrame);
   guiFrame->AddFrame(sliderFrame, new TGLayoutHints(kLHintsExpandX, 2, 2, 2, 2));
   sliderFrame->AddFrame(new TGLabel(sliderFrame, "Eta-Phi Range:"));

   CSGAction* actionRange = new CSGAction(this, "Scale eta-phi range");
   actionRange->createSlider(sliderFrame, new TGLayoutHints(kLHintsNormal| kLHintsCenterY, 2, 2, 0, 0), 120, kSlider1);
   actionRange->intSignal->connect(boost::bind(&FWECALDetailView::setEtaPhiRange,this,_1));
   TGSlider* slider  = actionRange->getSlider();
   slider->SetRange(-1000, 2000);
   slider->SetPosition(0);

   CSGAction* actionRnr = new CSGAction(this, "Render Eta-Phi Rng");
   actionRnr->createCheckButton(guiFrame, new TGLayoutHints(kLHintsNormal, 2, 2, 0, 0));
   actionRnr->activated.connect( sigc::mem_fun(this, &FWECALDetailView::buttonCallback));
     
   ediFrame->MapSubwindows();
   ediFrame->Layout();
}

template <typename T>
void FWECALDetailView<T>::buttonCallback()
{
   bool rnr = m_bLines->GetRnrSelf();
   m_bLines->SetRnrSelf(!rnr);

   m_bScene->Repaint();
   m_bViewer->GetGLViewer()->RequestDraw(TGLRnrCtx::kLODHigh);
   gEve->Redraw3D();
}

template <typename T>
void FWECALDetailView<T>::setEtaPhiRange(int x)
{
   Float_t val =  TMath::Power(10, x*1e-3);
   Float_t h = 0;
   Float_t a = 10*val;
   m_bLines->GetLinePlex().Reset(sizeof(TEveStraightLineSet::Line_t), 6);
   m_bLines->AddLine( +a, +a, +h, -a, -a, +h);
   m_bLines->AddLine( +a, -a, +h, -a, +a, +h);
   m_bLines->AddLine( -a, -a, +h, -a, +a, +h);
   m_bLines->AddLine( +a, -a, +h, +a, +a, +h);
   m_bLines->AddLine( +a, +a, +h, -a, +a, +h);
   m_bLines->AddLine( +a, -a, +h, -a, -a, +h);
   m_bLines->ComputeBBox();

   m_bScene->Repaint(true);
   m_bViewer->GetGLViewer()->RequestDraw(TGLRnrCtx::kLODHigh);
   gEve->Redraw3D();
}
//--------------------------------------------------------------------------------

template <typename T>
void FWECALDetailView<T>::build_projectedDave(const FWModelId &id, const T *i, TEveWindowSlot* slot)
{

   TGVerticalFrame *ediFrame;
   TEveViewer      *eveViewer;
   TEveScene       *scene;
   TEveWindow* ew = FWDetailViewBase::makePackViewer(slot, ediFrame, eveViewer, scene);
   ew->SetElementName("View C");
}
//--------------------------------------------------------------------------------
template <typename T>
void FWECALDetailView<T>::build_projectedJohannes(const FWModelId &id, const T *i, TEveWindowSlot* slot)
{
   // get rechits
   const fwlite::Event *ev = m_item->getEvent();
   fwlite::Handle<EcalRecHitCollection> handle_barrel_hits;
   m_barrel_hits = 0;
   try {
      handle_barrel_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEB");
      m_barrel_hits = handle_barrel_hits.ptr();
   }
   catch (...)
   {
      std::cout <<"no barrel ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }

   fwlite::Handle<EcalRecHitCollection> handle_endcap_hits;
   m_endcap_hits = 0;
   try {
      handle_endcap_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEE");
      m_endcap_hits = handle_endcap_hits.ptr();
   }
   catch ( ...)
   {
      std::cout <<"no endcap ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }

   assert(i->superCluster().isNonnull());

   std::vector< std::pair<DetId, float> > detids = i->superCluster()->hitsAndFractions();
   seed_detids = i->superCluster()->seed()-> hitsAndFractions();
   const unsigned int subdetId = seed_detids.size() != 0 ? seed_detids.begin()->first.subdetId() : 0;
   m_coordEtaPhi = (subdetId == EcalEndcap) ? kFALSE: kTRUE;

   TGVerticalFrame *ediFrame;
   TEveViewer      *eveViewer;
   TEveScene       *scene;
   TEveWindow* ew = FWDetailViewBase::makePackViewer(slot, ediFrame, eveViewer, scene);
   TGLViewer* viewer = eveViewer->GetGLViewer();
   ew->SetElementName("View A");

   // points for centroids
   Double_t x(0), y(0), z(0);
   TEveStraightLineSet *scposition = new TEveStraightLineSet("sc position");
   scposition->SetDepthTest(kFALSE);
   if (subdetId == EcalBarrel) {
      x = i->caloPosition().eta();
      y = i->caloPosition().phi();
   } else if (subdetId == EcalEndcap) {
      x = i->caloPosition().x()*m_unitCM;
      y = i->caloPosition().y()*m_unitCM;
   }
   scposition->AddLine(x, y, z, x, y, z);
   scposition->AddMarker(0, 0.5);
   scposition->SetMarkerSize(2);
   scposition->SetMarkerColor(kBlue);
   scene->AddElement(scposition);

   // points for seed position
   TEveStraightLineSet *seedposition = new TEveStraightLineSet("seed position");
   seedposition->SetDepthTest(kFALSE);
   if (subdetId == EcalBarrel) {
      x  = i->superCluster()->seed()->position().eta();
      y  = i->superCluster()->seed()->position().phi();
   } else if (subdetId == EcalEndcap) {
      x  = i->superCluster()->seed()->position().x()*m_unitCM;
      y  = i->superCluster()->seed()->position().y()*m_unitCM;
   }
   seedposition->AddLine(x, y, z, x, y, z);
   seedposition->AddMarker(0, 0.5);
   seedposition->SetMarkerSize(2);
   seedposition->SetMarkerColor(kRed);
   scene->AddElement(seedposition);

   // data
   //
   TEveCaloDataVec* data = new TEveCaloDataVec(3);
   data->RefSliceInfo(0).Setup("seed cluster", 0.0, kMagenta+2);
   data->RefSliceInfo(1).Setup("other clusters", 0.0, kMagenta-5);
   data->RefSliceInfo(2).Setup("track intersections", 0.0, kWhite);

   // fill
   fillData(detids, data, i->superCluster()->seed()->position().phi());
   if (drawTrack()) {
      addTrackPointsInCaloData(i, subdetId, data);
   }

   // make grid
   Double_t em, eM, pm, pM;
   data->GetEtaLimits(em, eM);
   data->GetPhiLimits(pm, pM);
   data->SetAxisFromBins((eM-em)*0.05, (pM-pm)*0.05); // 5% percision
   if (detids.size() > 0 && detids.begin()->first.subdetId() == EcalEndcap) {
      data->GetEtaBins()->SetTitle("X[m]");
      data->GetPhiBins()->SetTitle("Y[m]");
   } else {
      data->GetEtaBins()->SetTitleFont(122);
      data->GetEtaBins()->SetTitle("h");
      data->GetPhiBins()->SetTitleFont(122);
      data->GetPhiBins()->SetTitle("f");
   }
   // add offset
   Float_t offe = (eM-em)*0.1;
   Float_t offp = (pM-pm)*0.1;
   em -= offe;
   eM += offe;
   pm -= offp;
   pM += offp;
   data->AddTower(em, eM, pm, pM);
   data->FillSlice(2, 0);

   // lego
   TEveCaloLego* lego = new TEveCaloLego(data);
   // scale and translate to real world coordinates
   lego->SetEta(em, eM);
   lego->SetPhiWithRng((pm+pM)*0.5, (pM-pm)*0.5); // phi range = 2* phiOffset
   Double_t legoScale = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
   lego->InitMainTrans();
   lego->RefMainTrans().SetScale(legoScale, legoScale, legoScale*0.5);
   lego->RefMainTrans().SetPos((eM+em)*0.5, (pM+pm)*0.5, 0);

   lego->SetAutoRebin(kFALSE);
   lego->Set2DMode(TEveCaloLego::kValSize);
   lego->SetProjection(TEveCaloLego::kAuto);
   lego->SetName("ECALDetail Lego");
   lego->SetFontColor(kGray);
   scene->AddElement(lego);

   if (drawTrack())
      drawCrossHair(i, subdetId, lego, scene);

   // draw axis at the window corners
   TEveCaloLegoOverlay* overlay = new TEveCaloLegoOverlay();
   overlay->SetShowPlane(kFALSE);
   overlay->SetShowPerspective(kFALSE);
   overlay->SetCaloLego(lego);
   viewer->AddOverlayElement(overlay);

   // set event handler and flip camera to top view at beginning
   viewer->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
   TEveLegoEventHandler* eh = new TEveLegoEventHandler("Lego",(TGWindow*)viewer->GetGLWidget(), (TObject*)viewer);
   viewer->SetEventHandler(eh);
   eh->Rotate(0, 10000, kFALSE, kFALSE);

   viewer->UpdateScene();
   viewer->CurrentCamera().Reset();

   // draw legend in latex
   TRootEmbeddedCanvas* ec = new TRootEmbeddedCanvas("Embeddedcanvas", ediFrame, 100, 100, 0);
   ediFrame->AddFrame(ec, new TGLayoutHints(kLHintsExpandX|kLHintsExpandY));
   ediFrame->MapSubwindows();
   ediFrame->Layout();
   TCanvas* textCanvas = ec->GetCanvas();
   textCanvas->SetBorderMode(0);
   makeLegend(*i, textCanvas);
}

//______________________________________________________________________________
template <typename T>
void FWECALDetailView<T>::getEcalCrystalsBarrel (std::vector<DetId> *vv,
                                                 int ieta, int iphi)
{
   std::vector<DetId> &v = *vv;
   const int n_eta = 10;
   const int n_phi = 20;
   v.reserve((2 * n_eta + 1) * (2 * n_phi + 1));
   for (int i = ieta - n_eta; i < ieta + n_eta; ++i) {
      for (int j = iphi - n_phi; j < iphi + n_phi; ++j) {
         // printf("pushing back (%d, %d)\n", i, j % 360);
         if (EBDetId::validDetId(i, j % 360)) {
            v.push_back(EBDetId(i, j % 360));
            // printf("pushing back (%d, %d)\n", i, j % 360);
         }
      }
   }
}

//______________________________________________________________________________
template <typename T>
void FWECALDetailView<T>::getEcalCrystalsEndcap (std::vector<DetId> *vv,
                                                 int ix, int iy, int iz)
{
   std::vector<DetId> &v = *vv;
   const int n_x = 10;
   const int n_y = 10;
   v.reserve((2 * n_x + 1) * (2 * n_y + 1));
   for (int i = ix - n_x; i < ix + n_x; ++i) {
      for (int j = iy - n_y; j < iy + n_y; ++j) {
         if (EEDetId::validDetId(i, j, iz)) {
            v.push_back(EEDetId(i, j, iz));
         }
      }
   }
}

template <typename T>
void FWECALDetailView<T>::fillData (const std::vector< std::pair<DetId, float> > &detids,
                                    TEveCaloDataVec *data,
                                    double phi_seed)
{
   for (std::vector< std::pair<DetId, float> >::const_iterator k = detids.begin();
        k != detids.end(); ++k) {
      double size = 50; // default size
      if (k->first.subdetId() == EcalBarrel) {
         if (m_barrel_hits != 0) {
            EcalRecHitCollection::const_iterator hit =
               m_barrel_hits->find(k->first);
            if (hit != m_barrel_hits->end()) {
               size = hit->energy();
            }
         }
      } else if (k->first.subdetId() == EcalEndcap) {
         if (m_endcap_hits != 0) {
            EcalRecHitCollection::const_iterator hit =
               m_endcap_hits->find(k->first);
            if (hit != m_endcap_hits->end()) {
               size = hit->energy();
            }
         }
      }
      const TGeoHMatrix *matrix = m_item->getGeom()->getMatrix(k->first.rawId());
      if ( matrix == 0 ) {
         printf("Warning: cannot get geometry for DetId: %d. Ignored.\n",k->first.rawId());
         continue;
      }
      TVector3 v(matrix->GetTranslation()[0],
                 matrix->GetTranslation()[1],
                 matrix->GetTranslation()[2]);
      int slice = 1;
      for (std::vector< std::pair<DetId, float> >::const_iterator i = seed_detids.begin();
           i != seed_detids.end(); ++i){
         if ( i->first == k->first) {
            slice = 0;
            break;
         }
      }


      if (m_coordEtaPhi) {
         double phi = v.Phi();
         if (v.Phi() > phi_seed + M_PI)
            phi -= 2 * M_PI;
         if (v.Phi() < phi_seed - M_PI)
            phi += 2 * M_PI;
         data->AddTower(v.Eta() - 0.0172 / 2, v.Eta() + 0.0172 / 2,
                        phi - 0.0172 / 2, phi + 0.0172 / 2);
         data->FillSlice(slice, size);
      } else if (k->first.subdetId() == EcalEndcap) {
         // switch from cm to m
         data->AddTower((v.X() - 2.9 / 2)*m_unitCM, (v.X() + 2.9 / 2)*m_unitCM,
                        (v.Y() - 2.9 / 2)*m_unitCM, (v.Y() + 2.9 / 2)*m_unitCM);
         data->FillSlice(slice, size);
      }
   }
   data->DataChanged();
}

template <typename T>
Bool_t FWECALDetailView<T>::checkRange(Double_t &em, Double_t& eM, Double_t &pm, Double_t& pM,
                                       Double_t eta, Double_t phi)
{
   Bool_t changed = kFALSE;

   //check eta
   if (eta < em)
   {
      em = eta;
      changed = kTRUE;
   }
   else if (eta > eM)
   {
      eM = eta;
      changed = kTRUE;
   }

   // check phi
   if (phi < pm)
   {
      pm = phi;
      changed = kTRUE;
   }
   else if (phi > pM)
   {
      pM = phi;
      changed = kTRUE;
   }
   return changed;
}


