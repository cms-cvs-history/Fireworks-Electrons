// $Id: FWECALDetailView.icc,v 1.20 2009/07/23 13:58:37 dmytro Exp $

// system include files
#include "TLatex.h"
#include "TAxis.h"
#include "TGeoBBox.h"

#include "TGLViewer.h"
#include "TGLOverlayButton.h"

#include "TEveManager.h"
#include "TEveCalo.h"
#include "TEveCaloData.h"
#define protected public
#include "TEveLegoEventHandler.h"
#undef protected
#include "TEveCaloLegoOverlay.h"
#include "TEveText.h"
#include "TEveGeoNode.h"
#include "TEveStraightLineSet.h"
#include "TEveTrack.h"
#include "TEveTrackPropagator.h"

// user include files
#include "Fireworks/Electrons/plugins/FWECALDetailView.h"
#include "Fireworks/Core/interface/FWDetailView.h"

#include "DataFormats/FWLite/interface/Event.h"
#include "DataFormats/FWLite/interface/Handle.h"
#include "Fireworks/Core/interface/FWModelId.h"
#include "Fireworks/Core/interface/FWEventItem.h"
#include "Fireworks/Core/interface/DetIdToMatrix.h"
#include "Fireworks/Core/interface/TEveElementIter.h"
#include "DataFormats/EgammaReco/interface/BasicClusterShapeAssociation.h"
#include "DataFormats/EgammaReco/interface/BasicCluster.h"
#include "DataFormats/EcalDetId/interface/EBDetId.h"
#include "DataFormats/EcalDetId/interface/EEDetId.h"
#include "DataFormats/EcalDetId/interface/EcalSubdetector.h"

template <typename T>
FWECALDetailView<T>::FWECALDetailView () :
   m_unitCM(0.01),
   m_item(0),
   m_coordEtaPhi(true),
   m_barrel_hits(0),
   m_endcap_hits(0),
   m_endcap_reduced_hits(0)
{
}

template <typename T>
FWECALDetailView<T>::~FWECALDetailView ()
{

}

template <typename T>
void  FWECALDetailView<T>::clearOverlayElements()
{
   TGLOverlayElement* ov;
   for(std::vector<TGLOverlayElement* >::iterator it = m_overlays.begin();  it != m_overlays.end(); it++)
   {
      ov = *it;
      TEveCaloLegoOverlay* lo = dynamic_cast<TEveCaloLegoOverlay*>(ov);
      if (lo) FWDetailViewBase::viewer()->RemoveOverlayElement(ov);
   }
   m_overlays.clear();
}


template <typename T>
math::XYZPoint FWECALDetailView<T>::trackPositionAtCalo (const T &)
{
   return math::XYZPoint();
}

template <typename T>
double FWECALDetailView<T>::deltaEtaSuperClusterTrackAtVtx (const T &)
{
   return 0;
}

template <typename T>
double FWECALDetailView<T>::deltaPhiSuperClusterTrackAtVtx (const T &)
{
   return 0;
}

template <typename T>
void FWECALDetailView<T>::build_projected (const FWModelId &id, const T *i,
					   class TEveElementList *tList)
{
   // get rechits
   const fwlite::Event *ev = m_item->getEvent();
   fwlite::Handle<EcalRecHitCollection> handle_barrel_hits;
   m_barrel_hits = 0;
   try {
      handle_barrel_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEB");
      m_barrel_hits = handle_barrel_hits.ptr();
   }
   catch (...)
   {
      std::cout <<"no barrel ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }
   fwlite::Handle<EcalRecHitCollection> handle_endcap_hits;
   m_endcap_hits = 0;
   try {
      handle_endcap_hits.getByLabel(*ev, "ecalRecHit", "EcalRecHitsEE");
      m_endcap_hits = handle_endcap_hits.ptr();
   }
   catch ( ...)
   {
      std::cout <<"no endcap ECAL rechits are available, "
         "showing crystal location but not energy" << std::endl;
   }

   assert(i->superCluster().isNonnull());

   tList->AddElement(makeLabels(*i));
   std::vector< std::pair<DetId, float> > detids = i->superCluster()->hitsAndFractions();
   seed_detids = i->superCluster()->seed()-> hitsAndFractions();
   const unsigned int subdetId = seed_detids.size() != 0 ? seed_detids.begin()->first.subdetId() : 0;
   m_coordEtaPhi = (subdetId == EcalEndcap) ? kFALSE: kTRUE;


   // points for centroids
   Double_t x(0), y(0), z(0);
   TEveStraightLineSet *scposition = new TEveStraightLineSet("sc position");
   scposition->SetDepthTest(kFALSE);
   if (subdetId == EcalBarrel) {
      x = i->caloPosition().eta();
      y = i->caloPosition().phi();
   } else if (subdetId == EcalEndcap) {
      x = i->caloPosition().x()*m_unitCM;
      y = i->caloPosition().y()*m_unitCM;
   }
   scposition->AddLine(x, y, z, x, y, z);
   scposition->AddMarker(0, 0.5);
   scposition->SetMarkerSize(2);
   scposition->SetMarkerColor(kBlue);
   tList->AddElement(scposition);

   // points for seed position
   TEveStraightLineSet *seedposition = new TEveStraightLineSet("seed position");
   seedposition->SetDepthTest(kFALSE);
   if (subdetId == EcalBarrel) {
      x  = i->superCluster()->seed()->position().eta();
      y  = i->superCluster()->seed()->position().phi();
   } else if (subdetId == EcalEndcap) {
      x  = i->superCluster()->seed()->position().x()*m_unitCM;
      y  = i->superCluster()->seed()->position().y()*m_unitCM;
   }
   seedposition->AddLine(x, y, z, x, y, z);
   seedposition->AddMarker(0, 0.5);
   seedposition->SetMarkerSize(2);
   seedposition->SetMarkerColor(kRed);
   tList->AddElement(seedposition);


   // data
   //
   TEveCaloDataVec* data = new TEveCaloDataVec(3);
   data->RefSliceInfo(0).Setup("seed cluster", 0.0, kMagenta+2);
   data->RefSliceInfo(1).Setup("other clusters", 0.0, kMagenta-5);
   data->RefSliceInfo(2).Setup("track intersections", 0.0, kWhite);

   // fill
   fillData(detids, data, i->superCluster()->seed()->position().phi());
   if (drawTrack()) {
      addTrackPointsInCaloData(i, subdetId, data);
   }

   // make grid
   Double_t em, eM, pm, pM;
   data->GetEtaLimits(em, eM);
   data->GetPhiLimits(pm, pM);
   data->SetAxisFromBins((eM-em)*0.05, (pM-pm)*0.05); // 5% percision
   if (detids.size() > 0 && detids.begin()->first.subdetId() == EcalEndcap) {
      data->GetEtaBins()->SetTitle("X[m]");
      data->GetPhiBins()->SetTitle("Y[m]");
   } else {
      data->GetEtaBins()->SetTitleFont(122);
      data->GetEtaBins()->SetTitle("h");
      data->GetPhiBins()->SetTitleFont(122);
      data->GetPhiBins()->SetTitle("f");
   }
   // add offset
   Float_t offe = (eM-em)*0.1;
   Float_t offp = (pM-pm)*0.1;
   em -= offe;
   eM += offe;
   pm -= offp;
   pM += offp;
   data->AddTower(em, eM, pm, pM);
   data->FillSlice(2, 0);

   // lego
   TEveCaloLego* lego = new TEveCaloLego(data);
   // scale and translate to real world coordinates
   lego->SetEta(em, eM);
   lego->SetPhiWithRng((pm+pM)*0.5, (pM-pm)*0.5); // phi range = 2* phiOffset
   Double_t legoScale = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
   lego->InitMainTrans();
   lego->RefMainTrans().SetScale(legoScale, legoScale, legoScale*0.5);
   lego->RefMainTrans().SetPos((eM+em)*0.5, (pM+pm)*0.5, 0);

   lego->SetAutoRebin(kFALSE);
   lego->Set2DMode(TEveCaloLego::kValSize);
   lego->SetProjection(TEveCaloLego::kAuto);
   lego->SetName("ElectronDetail Lego");
   lego->SetFontColor(kGray);
   gEve->AddElement(lego, tList);


   if (drawTrack()) {
      drawCrossHair(i, subdetId, lego, tList);
   }

   // draw axis at the window corners
   TEveCaloLegoOverlay* overlay = new TEveCaloLegoOverlay();
   overlay->SetShowPlane(kFALSE);
   overlay->SetShowPerspective(kFALSE);
   overlay->SetCaloLego(lego);
   FWDetailViewBase::viewer()->AddOverlayElement(overlay);
   m_overlays.push_back(overlay);

   // set event handler and flip camera to top view at beginning
   FWDetailViewBase::viewer()->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
   //   FWDetailViewBase::viewer()->SetGuideState(TGLUtil::kAxesNone, kTRUE, kFALSE, 0);
   TGLViewer* fwdv =  FWDetailViewBase::viewer();
   TEveLegoEventHandler* eh = new TEveLegoEventHandler("Lego",(TGWindow*)fwdv->GetGLWidget(), (TObject*)fwdv);
   fwdv->SetEventHandler(eh);
   eh->Rotate(0, 10000, kFALSE, kFALSE);
}

//______________________________________________________________________________
template <typename T>
void FWECALDetailView<T>::getEcalCrystalsBarrel (std::vector<DetId> *vv,
						 int ieta, int iphi)
{
   std::vector<DetId> &v = *vv;
   const int n_eta = 10;
   const int n_phi = 20;
   v.reserve((2 * n_eta + 1) * (2 * n_phi + 1));
   for (int i = ieta - n_eta; i < ieta + n_eta; ++i) {
      for (int j = iphi - n_phi; j < iphi + n_phi; ++j) {
         // printf("pushing back (%d, %d)\n", i, j % 360);
         if (EBDetId::validDetId(i, j % 360)) {
            v.push_back(EBDetId(i, j % 360));
            // printf("pushing back (%d, %d)\n", i, j % 360);
         }
      }
   }
}

//______________________________________________________________________________
template <typename T>
void FWECALDetailView<T>::getEcalCrystalsEndcap (std::vector<DetId> *vv,
                                                 int ix, int iy, int iz)
{
   std::vector<DetId> &v = *vv;
   const int n_x = 10;
   const int n_y = 10;
   v.reserve((2 * n_x + 1) * (2 * n_y + 1));
   for (int i = ix - n_x; i < ix + n_x; ++i) {
      for (int j = iy - n_y; j < iy + n_y; ++j) {
         if (EEDetId::validDetId(i, j, iz)) {
            v.push_back(EEDetId(i, j, iz));
         }
      }
   }
}

//______________________________________________________________________________
template <typename T>
void FWECALDetailView<T>::fillData (const std::vector< std::pair<DetId, float> > &detids,
				    TEveCaloDataVec *data,
				    double phi_seed)
{
   for (std::vector< std::pair<DetId, float> >::const_iterator k = detids.begin();
        k != detids.end(); ++k) {
      double size = 50; // default size
      if (k->first.subdetId() == EcalBarrel) {
         if (m_barrel_hits != 0) {
            EcalRecHitCollection::const_iterator hit =
               m_barrel_hits->find(k->first);
            if (hit != m_barrel_hits->end()) {
               size = hit->energy();
            }
         }
      } else if (k->first.subdetId() == EcalEndcap) {
         if (m_endcap_hits != 0) {
            EcalRecHitCollection::const_iterator hit =
               m_endcap_hits->find(k->first);
            if (hit != m_endcap_hits->end()) {
               size = hit->energy();
            }
         }
      }
      const TGeoHMatrix *matrix = m_item->getGeom()->getMatrix(k->first.rawId());
      if ( matrix == 0 ) {
         printf("Warning: cannot get geometry for DetId: %d. Ignored.\n",k->first.rawId());
         continue;
      }
      TVector3 v(matrix->GetTranslation()[0],
                 matrix->GetTranslation()[1],
                 matrix->GetTranslation()[2]);
      int slice = 1;
      for (std::vector< std::pair<DetId, float> >::const_iterator i = seed_detids.begin();
	   i != seed_detids.end(); ++i){
	 if ( i->first == k->first) {
	    slice = 0;
	    break;
	 }
      }


      if (m_coordEtaPhi) {
         double phi = v.Phi();
         if (v.Phi() > phi_seed + M_PI)
            phi -= 2 * M_PI;
         if (v.Phi() < phi_seed - M_PI)
            phi += 2 * M_PI;
         data->AddTower(v.Eta() - 0.0172 / 2, v.Eta() + 0.0172 / 2,
                        phi - 0.0172 / 2, phi + 0.0172 / 2);
         data->FillSlice(slice, size);
      } else if (k->first.subdetId() == EcalEndcap) {
         // switch from cm to m
         data->AddTower((v.X() - 2.9 / 2)*m_unitCM, (v.X() + 2.9 / 2)*m_unitCM,
                        (v.Y() - 2.9 / 2)*m_unitCM, (v.Y() + 2.9 / 2)*m_unitCM);
         data->FillSlice(slice, size);
      }
   }
   data->DataChanged();
}

//______________________________________________________________________________
template <typename T>
Bool_t FWECALDetailView<T>::checkRange(Double_t &em, Double_t& eM, Double_t &pm, Double_t& pM,
                                       Double_t eta, Double_t phi)
{
   Bool_t changed = kFALSE;

   //check eta
   if (eta < em)
   {
      em = eta;
      changed = kTRUE;
   }
   else if (eta > eM)
   {
      eM = eta;
      changed = kTRUE;
   }

   // check phi
   if (phi < pm)
   {
      pm = phi;
      changed = kTRUE;
   }
   else if (phi > pM)
   {
      pM = phi;
      changed = kTRUE;
   }
   return changed;
}

